<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Transmisor</title>
<style>
  :root{--bg:rgb(0,50,50);--log-bg:rgba(0,0,0,0.6);--text:#7CFC00}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:monospace}
  h2{padding:12px 16px;margin:0}
  video{width:100%;display:block;background:#000}
  #controls{padding:12px 16px}
  #logArea{position:fixed;left:0;right:0;bottom:0;pointer-events:auto;padding:8px;display:flex;flex-direction:column-reverse;gap:8px;z-index:9999}
  .logEntry{background:var(--log-bg);color:var(--text);padding:8px 12px;border-radius:6px;display:flex;align-items:flex-start;gap:8px;max-width:95%;margin-left:8px}
  .logMsg{flex:1;white-space:pre-wrap}
  .logClose{font-weight:700;background:transparent;border:none;color:#ff7777;font-size:18px;cursor:pointer;padding:0 8px}
  .bigX{font-size:22px;color:#ff4444;margin-left:8px}
  button{padding:8px 12px;font-size:16px}
  .status{padding:8px 12px}
</style>
</head>
<body>
<h2>Transmisor de pantalla</h2>
<div id="controls">
  <button id="startBtn">Iniciar transmisión</button>
  <span id="status" class="status">Idle</span>
</div>
<video id="localPreview" autoplay playsinline muted></video>

<div id="logArea" aria-live="polite"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import { getDatabase, ref, push, set, onChildAdded, onValue, remove } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyB-g5vDBoRBBXRA4sHSSUoSb1mOAzW7dvE",
  authDomain: "screenshare-c9b90.firebaseapp.com",
  databaseURL: "https://screenshare-c9b90-default-rtdb.firebaseio.com",
  projectId: "screenshare-c9b90",
  storageBucket: "screenshare-c9b90.firebasestorage.app",
  messagingSenderId: "773043733347",
  appId: "1:773043733347:web:91aa0217bcf05a11990956",
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const sessionBase = 'webrtc/session1/viewers';
const startBtn = document.getElementById('startBtn');
const statusEl = document.getElementById('status');
const localPreview = document.getElementById('localPreview');
const logArea = document.getElementById('logArea');

function log(msg){
  const id = Date.now().toString(36) + Math.random().toString(36).slice(2,8);
  const entry = document.createElement('div');
  entry.className = 'logEntry';
  entry.id = 'log-'+id;
  const m = document.createElement('div');
  m.className = 'logMsg';
  m.innerText = msg;
  const btn = document.createElement('button');
  btn.className = 'logClose';
  btn.innerText = '✕';
  btn.title = 'Cerrar';
  btn.onclick = ()=> entry.remove();
  entry.appendChild(m);
  entry.appendChild(btn);
  logArea.prepend(entry);
}

let localStream = null;

startBtn.onclick = async () => {
  try{
    setStatus('Obteniendo pantalla...');
    localStream = await navigator.mediaDevices.getDisplayMedia({video:true,audio:false});
    localPreview.srcObject = localStream;
    log('Captura de pantalla iniciada');
    setStatus('Escuchando viewers...');
    // start listening for viewers
    listenForViewers();
  }catch(err){
    log('Error al obtener pantalla: ' + (err && err.message ? err.message : err));
    setStatus('Error');
  }
};

function setStatus(t){ statusEl.innerText = t; }

function listenForViewers(){
  // don't remove whole viewers node. just listen for child_added.
  const viewersRef = ref(db, sessionBase);
  onChildAdded(viewersRef, async (snap) => {
    const viewerId = snap.key;
    log('Nuevo viewer detectado: ' + viewerId);
    const viewerPath = sessionBase + '/' + viewerId;
    // create a peer connection per viewer
    const pc = new RTCPeerConnection();
    // add tracks
    if(localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
    else log('Advertencia: no hay stream local aun.');

    // when transmitter gets ICE candidates, push them to database under senderCandidates
    pc.onicecandidate = (e) => {
      if(e.candidate){
        const cRef = push(ref(db, viewerPath + '/senderCandidates'));
        set(cRef, e.candidate.toJSON());
        log('Transmitter: enviado candidate -> ' + JSON.stringify(e.candidate.toJSON()));
      }
    };

    // listen for viewer's candidates
    const viewerCandidatesRef = ref(db, viewerPath + '/viewerCandidates');
    onChildAdded(viewerCandidatesRef, async (snapC) => {
      const cand = snapC.val();
      try{
        await pc.addIceCandidate(cand);
        log('Transmitter: agregado viewer candidate -> ' + JSON.stringify(cand));
      }catch(e){
        log('Transmitter: fallo addIceCandidate ' + (e.message||e));
      }
    });

    // create offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    // write offer to viewer node
    set(ref(db, viewerPath + '/offer'), offer);
    log('Transmitter: oferta creada y guardada para ' + viewerId);

    // wait for answer
    onValue(ref(db, viewerPath + '/answer'), async (snapA) => {
      if(!snapA.exists()) return;
      const answer = snapA.val();
      try{
        await pc.setRemoteDescription(answer);
        log('Transmitter: respuesta recibida y aplicada para ' + viewerId);
        setStatus('Transmitiendo a ' + viewerId);
      }catch(e){
        log('Transmitter: fallo setRemoteDescription ' + (e.message||e));
      }
    });

  });
  log('Listener activo sobre ' + sessionBase);
}
</script>
</body>
</html>
