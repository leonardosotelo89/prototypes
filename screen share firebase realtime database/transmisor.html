<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Transmisor</title>
<style>
  :root{--bg:rgb(0,50,50);--log-bg:rgba(0,0,0,0.6);--text:#7CFC00}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:monospace}
  h2{padding:12px 16px;margin:0}
  video{width:100%;display:block;background:#000}
  #controls{padding:12px 16px}
  #logArea{position:fixed;left:0;right:0;bottom:0;pointer-events:auto;padding:8px;display:flex;flex-direction:column-reverse;gap:8px;z-index:9999}
  .logEntry{background:var(--log-bg);color:var(--text);padding:8px 12px;border-radius:6px;display:flex;align-items:flex-start;gap:8px;max-width:95%;margin-left:8px}
  .logMsg{flex:1;white-space:pre-wrap}
  .logClose{font-weight:700;background:transparent;border:none;color:#ff7777;font-size:18px;cursor:pointer;padding:0 8px}
  button{padding:8px 12px;font-size:16px}
  .status{padding:8px 12px}
</style>
</head>
<body>
<h2>Transmisor de pantalla</h2>
<div id="controls">
  <button id="startBtn">Iniciar transmisión</button>
  <span id="status" class="status">Idle</span>
</div>
<video id="localPreview" autoplay playsinline muted></video>

<div id="logArea" aria-live="polite"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import { getDatabase, ref, push, set, onChildAdded, onValue } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyB-g5vDBoRBBXRA4sHSSUoSb1mOAzW7dvE",
  authDomain: "screenshare-c9b90.firebaseapp.com",
  databaseURL: "https://screenshare-c9b90-default-rtdb.firebaseio.com",
  projectId: "screenshare-c9b90",
  storageBucket: "screenshare-c9b90.firebasestorage.app",
  messagingSenderId: "773043733347",
  appId: "1:773043733347:web:91aa0217bcf05a11990956",
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const sessionBase = 'webrtc/session1/viewers';

const startBtn = document.getElementById('startBtn');
const statusEl = document.getElementById('status');
const localPreview = document.getElementById('localPreview');
const logArea = document.getElementById('logArea');

function log(msg){
  const id = Date.now().toString(36) + Math.random().toString(36).slice(2,8);
  const entry = document.createElement('div');
  entry.className = 'logEntry';
  entry.id = 'log-'+id;
  const m = document.createElement('div');
  m.className = 'logMsg';
  m.innerText = msg;
  const btn = document.createElement('button');
  btn.className = 'logClose';
  btn.innerText = '✕';
  btn.title = 'Cerrar';
  btn.onclick = ()=> entry.remove();
  entry.appendChild(m);
  entry.appendChild(btn);
  logArea.prepend(entry);
}

function setStatus(t){ statusEl.innerText = t; }

let localStream = null;

startBtn.onclick = async () => {
  try {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
      log("getDisplayMedia no soportado, intentando usar cámara como fallback.");
      localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:false});
      localPreview.srcObject = localStream;
      setStatus("Transmitiendo cámara (sin soporte de screen share)");
      listenForViewers();
      return;
    }
    log("Esperando permiso del usuario para compartir pantalla...");
    setStatus("Esperando permiso...");
    localStream = await navigator.mediaDevices.getDisplayMedia({video:true,audio:false});
    if (!localStream) {
      log("El usuario canceló la captura o no se obtuvo stream.");
      setStatus("Cancelado");
      return;
    }
    localPreview.srcObject = localStream;
    log("Permiso concedido, pantalla capturada.");
    setStatus("Transmitiendo pantalla");
    listenForViewers();
  } catch(err) {
    log("Error al obtener pantalla: " + (err && err.message ? err.message : err));
    setStatus("Error");
  }
};

function listenForViewers(){
  const viewersRef = ref(db, sessionBase);
  onChildAdded(viewersRef, async (snap) => {
    const viewerId = snap.key;
    log("Nuevo viewer detectado: " + viewerId);
    const viewerPath = sessionBase + "/" + viewerId;
    const pc = new RTCPeerConnection();
    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        const cRef = push(ref(db, viewerPath + "/senderCandidates"));
        set(cRef, e.candidate.toJSON());
        log("Transmitter: enviado candidate");
      }
    };

    const viewerCandidatesRef = ref(db, viewerPath + "/viewerCandidates");
    onChildAdded(viewerCandidatesRef, async (snapC) => {
      const cand = snapC.val();
      try {
        await pc.addIceCandidate(cand);
        log("Transmitter: agregado viewer candidate");
      } catch(e) {
        log("Error ICE viewer: " + (e.message||e));
      }
    });

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    set(ref(db, viewerPath + "/offer"), offer);
    log("Transmitter: oferta creada");

    onValue(ref(db, viewerPath + "/answer"), async (snapA) => {
      if (!snapA.exists()) return;
      const answer = snapA.val();
      try {
        await pc.setRemoteDescription(answer);
        log("Transmitter: respuesta recibida");
        setStatus("Transmitiendo a " + viewerId);
      } catch(e) {
        log("Error respuesta: " + (e.message||e));
      }
    });
  });
  log("Esperando viewers...");
}
</script>
</body>
</html>
